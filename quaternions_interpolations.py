# -*- coding: utf-8 -*-
"""quaternions-interpolations-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LXOIGBhk_O45GTIJu-Mw97Jc6pr6no41
"""

import numpy as np
from scipy.spatial.transform import Rotation
import matplotlib.pyplot as plt

def euler_interpolation(rotation1, rotation2, num_steps):
    angles1 = rotation1.as_euler('xyz', degrees=True)
    angles2 = rotation2.as_euler('xyz', degrees=True)
    interpolated_rotations = []
    for t in np.linspace(0, 1, num_steps):
        interpolated_angles = angles1 * (1 - t) + angles2 * t
        interpolated_rotation = Rotation.from_euler('xyz', interpolated_angles, degrees=True)
        interpolated_rotations.append(interpolated_rotation)
    return interpolated_rotations

def quaternion_interpolation(quaternion1, quaternion2, num_steps):
    dot = np.dot(quaternion1, quaternion2)
    if dot < 0.0:
        quaternion1 = -quaternion1
        dot = -dot
    if dot > 0.9995:
        interpolated_quaternions = [quaternion1 + t * (quaternion2 - quaternion1) for t in np.linspace(0, 1, num_steps)]
        interpolated_quaternions = np.array(interpolated_quaternions)
        interpolated_quaternions /= np.linalg.norm(interpolated_quaternions, axis=1)[:, np.newaxis]
        return interpolated_quaternions
    theta_0 = np.arccos(dot)
    sin_theta_0 = np.sin(theta_0)
    interpolated_quaternions = []
    for t in np.linspace(0, 1, num_steps):
        theta = theta_0 * t
        sin_theta = np.sin(theta)
        s0 = np.cos(theta) - dot * sin_theta / sin_theta_0
        s1 = sin_theta / sin_theta_0
        interpolated_quaternion = (s0 * quaternion1) + (s1 * quaternion2)
        interpolated_quaternions.append(interpolated_quaternion)
    interpolated_quaternions = np.array(interpolated_quaternions)
    interpolated_quaternions /= np.linalg.norm(interpolated_quaternions, axis=1)[:, np.newaxis]
    return interpolated_quaternions

# Define two rotations as Euler angles
rotation1_euler = Rotation.from_euler('xyz', [45, 30, 60], degrees=True)
rotation2_euler = Rotation.from_euler('xyz', [90, -45, 20], degrees=True)

# Convert Euler angles to quaternions
quaternion1 = rotation1_euler.as_quat()
quaternion2 = rotation2_euler.as_quat()

# Interpolate using Euler angles
num_steps = 10
interpolated_rotations_euler = euler_interpolation(rotation1_euler, rotation2_euler, num_steps)

# Interpolate using quaternions
interpolated_quaternions = quaternion_interpolation(quaternion1, quaternion2, num_steps)
interpolated_rotations_quaternion = [Rotation.from_quat(q) for q in interpolated_quaternions]

# Plotting
fig, axes = plt.subplots(1, num_steps, figsize=(15, 5))

for i in range(num_steps):
    orientation_euler = interpolated_rotations_euler[i].apply([1, 0, 0])
    orientation_quaternion = interpolated_rotations_quaternion[i].apply([1, 0, 0])

    ax = axes[i]
    ax.plot([0, orientation_euler[0]], [0, orientation_euler[1]], label='Euler Interpolation', color='b')
    ax.plot([0, orientation_quaternion[0]], [0, orientation_quaternion[1]], label='Quaternion Interpolation', color='r')
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_title(f'Step {i+1}')

axes[0].legend(bbox_to_anchor=(1.95, 1.25))
#plt.tight_layout()
plt.show()



"""This code will generate a plot with subplots for each interpolation step, comparing the interpolated orientations using Euler angle interpolation (blue) and quaternion interpolation (red). Each subplot represents the interpolated orientation at a specific step of the interpolation process, allowing for visual comparison between the two methods."""
